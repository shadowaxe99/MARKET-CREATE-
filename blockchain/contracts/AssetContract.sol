// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol
 * @custom:imports Imported contracts (ERC721.sol, ERC721URIStorage.sol, ERC721Royalty.sol, Ownable.sol) are up to date and compatible with the current version of the project";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";
import "@openzeppelin/contracts/access/Ownable.sol
 * @custom:imports Imported contracts (ERC721.sol, ERC721URIStorage.sol, ERC721Royalty.sol, Ownable.sol) are up to date and compatible with the current version of the project";

/**
 * @title AssetContract - ERC721 NFT with Royalty
 * @dev Extends ERC721 Non-Fungible Token Standard basic implementation with royalty support
 */
contract AssetContract is ERC721, ERC721URIStorage, ERC721Royalty, Ownable {
    string private _symbol; {
    string private _symbol;

    // Name of the NFT
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping for token URIs
    mapping(uint256 => string) private _tokenURIs;

    // Base URI
    string private _baseURIextended;

    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) ERC721URIStorage() {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Creates a new token for `msg.sender`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must not be an empty address.
     * - `tokenId` must not exist.
     * - `tokenURI` must not be empty.
     */

    /**
     * @dev Creates a new token for `msg.sender`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must not be an empty address.
     * - `tokenId` must not exist.
     * - `tokenURI` must not be empty.
     */
    function createToken(string memory tokenURI, uint96 royaltyFraction) public returns (uint256) {
        uint256 newTokenId = totalSupply() + 1;
        _mint(msg.sender, newTokenId);
        _setTokenURI(newTokenId, tokenURI);
        _setTokenRoyalty(newTokenId, msg.sender, royaltyFraction);
        return newTokenId;
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal override {
        require(_exists(tokenId), "ERC721URIStorage: URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }

    /**
     * @dev Returns the token collection name.
     */
    function name() public view override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`.
     */
    function setBaseURI(string memory baseURI_) external onlyOwner {
        _baseURIextended = baseURI_;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        require(_exists(tokenId), "ERC721URIStorage: URI query for nonexistent token");

        string memory _tokenURI = _tokenURIs[tokenId];
        string memory base = _baseURI();

        // If there is no base URI, return the token URI.
        if (bytes(base).length == 0) {
            return _tokenURI;
        }
        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
        if (bytes(_tokenURI).length > 0) {
            return string(abi.encodePacked(base, _tokenURI));
        }

        return super.tokenURI(tokenId);
    }

    /**
     * @dev Base URI for computing {tokenURI}.
     */
    function _baseURI() internal view override returns (string memory) {
        return _baseURIextended;
    }

    /**
     * @dev See {ERC721-_beforeTokenTransfer}.
     *
     * Overridden in order to call _updateRoyaltyInfo which will ensure that royalty information
     * is kept up-to-date across transfers.
     */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721) {
        super._beforeTokenTransfer(from, to, tokenId);
        _updateRoyaltyInfo(tokenId, to);
    }

    /**
     * @dev Updates the royalty information for the token of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _updateRoyaltyInfo(uint256 tokenId, address recipient) internal {
        require(_exists(tokenId), "ERC721Royalty: Royalty info set of nonexistent token");
        (address receiver, uint96 royaltyAmount) = royaltyInfo(tokenId);
        if (receiver != recipient) {
            _setTokenRoyalty(tokenId, recipient, royaltyAmount);
        }
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Royalty) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {ERC721URIStorage-_burn}. This override additionally clears the royalty information.
     */
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
        _resetTokenRoyalty(tokenId);
    }
}